## 面向过程和面向对象

**面向过程**

面向过程是一种以过程为中心的设计思想，是一种自顶而下的设计模式，即把问题分解成一个一个步骤，每个步骤用函数去实现，依次调用即可
可以在`视图`菜单中关闭

不再显示关闭

**面向对象**

把问题分解成一个一个步骤，把每个步骤进行相应的抽象，形成对象，通过对象之间的调用，组合解决问题

## Java中基本数据类型

Java中有八种基本数据类型，分别是：

1.六种数字类型：``byte``、 ``short``、``int``、``long``、``float``、``double``

2.一种字符类型：``char``

3.一种布尔类型：``boolean``

## 说说 sleep() 方法和 wait() 方法的区别和共同点

* 两者主要的区别是 sleep()方法没有释放锁，而wait()方法释放了锁
* wait()方法被调用后，线程不会主动苏醒，需要别的线程调用同一对象上的 notify() 或者 notifyAll() 方法。 sleep() 方法执行完成后，线程会主动苏醒，或者使用 wait(long timeout) 超时后线程会主动苏醒 
* 两者都可以暂停线程的执行

## 说说 synchronized 关键字和 volatile 关键字的区别

* volatile 关键字是线程同步的轻量级实现，所以 volatile 关键字的性能肯定比 sychronized 关键字要好。但是 volatile 关键字只能用于变量，而 sychronized 关键字可以修饰方法和代码块
* volatile 关键字能保证数据的可见性，但是不能保证数据的原子性。synchronized 关键字两者都能够保证
* volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性

## 说说并行和并发的区别

* 并行：单位时间内，多个线程同时执行
* 并发：同一时间段，多个任务都在执行

## 什么是上下文切换

多线程编程中一般线程的个数都大于cpu的个数，而一个 cpu 核心在任意时刻只能被一个线程使用，为了让这些线程都能够得到有效执行，cpu 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候会重新处于就绪状态让其他线程使用，而这个过程就属于一次上下文切换

## 讲一讲JMM(Java内存模型)

在JDK1.2之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别注意的。而在当前的 Java内存模型中，线程可以把变量保存到本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成主存中修改一个变量的值，而两外一个线程继续使用它在寄存器中变量值的拷贝，造成数据的不一致。

## ThreadLocal 内存泄漏问题说一下

ThresdLocalMap 中使用的 Key 为ThreadLocal 的弱引用，而 Value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候， key 会被清理掉，而 value 不会被清理掉。这样一来， ThreadLocal 会出现 key 为 null 的 entry ,假如不采取任何措施的话，Value 永远不会被 GC 回收，这个时候就会出现内存泄漏，Threadlocal 实现中已经考虑到了这个问题，在调用 get()、set()、remove() 这些方法的时候，会清理掉key为null的记录，使用完 ThreadLocal 方法后最好手动调用remove()方法。