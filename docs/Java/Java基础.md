## 面向过程和面向对象

**面向过程**

面向过程是一种以过程为中心的设计思想，是一种自顶而下的设计模式，即把问题分解成一个一个步骤，每个步骤用函数去实现，依次调用即可
可以在`视图`菜单中关闭

不再显示关闭

**面向对象**

把问题分解成一个一个步骤，把每个步骤进行相应的抽象，形成对象，通过对象之间的调用，组合解决问题

## Java中基本数据类型

Java中有八种基本数据类型，分别是：

1.六种数字类型：``byte``、 ``short``、``int``、``long``、``float``、``double``

2.一种字符类型：``char``

3.一种布尔类型：``boolean``

## 说说 sleep() 方法和 wait() 方法的区别和共同点

* 两者主要的区别是 sleep()方法没有释放锁，而wait()方法释放了锁
* wait()方法被调用后，线程不会主动苏醒，需要别的线程调用同一对象上的 notify() 或者 notifyAll() 方法。 sleep() 方法执行完成后，线程会主动苏醒，或者使用 wait(long timeout) 超时后线程会主动苏醒 
* 两者都可以暂停线程的执行

## 说说 synchronized 关键字和 volatile 关键字的区别

* volatile 关键字是线程同步的轻量级实现，所以 volatile 关键字的性能肯定比 sychronized 关键字要好。但是 volatile 关键字只能用于变量，而 sychronized 关键字可以修饰方法和代码块
* volatile 关键字能保证数据的可见性，但是不能保证数据的原子性。synchronized 关键字两者都能够保证
* volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性

## 说说并行和并发的区别

* 并行：单位时间内，多个线程同时执行
* 并发：同一时间段，多个任务都在执行

## 什么是上下文切换

多线程编程中一般线程的个数都大于cpu的个数，而一个 cpu 核心在任意时刻只能被一个线程使用，为了让这些线程都能够得到有效执行，cpu 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候会重新处于就绪状态让其他线程使用，而这个过程就属于一次上下文切换

## 讲一讲JMM(Java内存模型)

在JDK1.2之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别注意的。而在当前的 Java内存模型中，线程可以把变量保存到本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成主存中修改一个变量的值，而两外一个线程继续使用它在寄存器中变量值的拷贝，造成数据的不一致。

## ThreadLocal 内存泄漏问题说一下

ThresdLocalMap 中使用的 Key 为ThreadLocal 的弱引用，而 Value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候， key 会被清理掉，而 value 不会被清理掉。这样一来， ThreadLocal 会出现 key 为 null 的 entry ,假如不采取任何措施的话，Value 永远不会被 GC 回收，这个时候就会出现内存泄漏，Threadlocal 实现中已经考虑到了这个问题，在调用 get()、set()、remove() 这些方法的时候，会清理掉key为null的记录，使用完 ThreadLocal 方法后最好手动调用remove()方法。

## 设计模式有哪些原则

**开闭原则 :** OOP中最基础的原则，指一个软件实体（类，模块，方法等）应该对扩展开放，对修改关闭。强调用抽象构建框架，用扩展实现细节，提高代码的可扩展性和可维护性。

**单一职责 ：** 一个类、接口或者是方法只负责一个职责，降低代码的复杂度以及变更引起的风险

**依赖倒置：** 程序应该依赖于抽象类或者是接口，而不是具体的实现类

**接口隔离原则：**将不同功能定义在不同接口中实现接口隔离，避免了类依赖它不需要的接口，减少了接口之间依赖的冗余性和复杂度

**里氏替换原则：** 规定了任何父类可以出现的地方，子类一定可以出现可以约束继承泛滥。加强程序的健壮性

**迪米特原则：** 也叫最少知道原则，每个模块对其他模块都要尽可能少的了解和依赖，降低代码的耦合度

**合成/聚合原则：** 尽量使用组合/聚合而不是继承达到软件复用的目的，避免滥用继承带来方法污染和方法爆炸，方法污染是指父类的行为通过继承传递给子类，但是子类并不具备执行此行为的能力。方法爆炸是指继承树不断扩大，底层拥有的方法过于繁杂，导致很容易选择错误